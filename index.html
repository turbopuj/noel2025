<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Memory de No√´l Collaboratif</title>
  <style>
:root {
  --color-white: rgba(255, 255, 255, 1);
  --color-black: rgba(0, 0, 0, 1);
  --color-cream-50: rgba(252, 252, 249, 1);
  --color-cream-100: rgba(255, 255, 253, 1);
  --color-gray-200: rgba(245, 245, 245, 1);
  --color-gray-300: rgba(167, 169, 169, 1);
  --color-gray-400: rgba(119, 124, 124, 1);
  --color-slate-500: rgba(98, 108, 113, 1);
  --color-brown-600: rgba(94, 82, 64, 1);
  --color-charcoal-700: rgba(31, 33, 33, 1);
  --color-charcoal-800: rgba(38, 40, 40, 1);
  --color-slate-900: rgba(19, 52, 59, 1);
  --color-teal-300: rgba(50, 184, 198, 1);
  --color-teal-400: rgba(45, 166, 178, 1);
  --color-teal-500: rgba(33, 128, 141, 1);
  --color-teal-600: rgba(29, 116, 128, 1);
  --color-teal-700: rgba(26, 104, 115, 1);
  --color-red-400: rgba(255, 84, 89, 1);
  --color-red-500: rgba(192, 21, 47, 1);
  --color-orange-400: rgba(230, 129, 97, 1);
  --color-orange-500: rgba(168, 75, 47, 1);
  --color-green-500: rgba(34, 197, 94, 1);
  --color-yellow-500: rgba(234, 179, 8, 1);
  --color-purple-500: rgba(168, 85, 247, 1);

  --color-brown-600-rgb: 94, 82, 64;
  --color-teal-500-rgb: 33, 128, 141;
  --color-slate-900-rgb: 19, 52, 59;
  --color-red-500-rgb: 192, 21, 47;
  --color-green-500-rgb: 34, 197, 94;
  --color-yellow-500-rgb: 234, 179, 8;
  --color-purple-500-rgb: 168, 85, 247;

  --color-background: var(--color-cream-50);
  --color-surface: var(--color-cream-100);
  --color-text: var(--color-slate-900);
  --color-text-secondary: var(--color-slate-500);
  --color-primary: var(--color-teal-500);
  --color-primary-hover: var(--color-teal-600);
  --color-border: rgba(var(--color-brown-600-rgb), 0.2);
  --color-error: var(--color-red-500);
  --color-success: var(--color-green-500);
  --color-warning: var(--color-yellow-500);
  --color-admin: var(--color-purple-500);

  --font-family-base: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
  --font-size-sm: 12px;
  --font-size-base: 14px;
  --font-size-lg: 16px;
  --font-size-xl: 18px;
  --font-size-2xl: 20px;
  --font-size-3xl: 24px;

  --space-4: 4px;
  --space-8: 8px;
  --space-12: 12px;
  --space-16: 16px;
  --space-24: 24px;
  --space-32: 32px;

  --radius-base: 8px;
  --radius-lg: 12px;
  --radius-xl: 16px;

  --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.08);
  --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
  --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1);

  --christmas-red: #c1272d;
  --christmas-green: #165b33;
  --christmas-gold: #ffd700;
}
@media (prefers-color-scheme: dark) {
  :root {
    --color-background: var(--color-charcoal-700);
    --color-surface: var(--color-charcoal-800);
    --color-text: var(--color-gray-200);
    --color-text-secondary: rgba(167, 169, 169, 0.7);
    --color-primary: var(--color-teal-300);
    --color-primary-hover: var(--color-teal-400);
    --color-border: rgba(119, 124, 124, 0.3);
    --color-error: var(--color-red-400);
  }
}
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  font-family: var(--font-family-base);
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  min-height: 100vh;
  color: var(--color-text);
  padding: var(--space-16);
  overflow-x: hidden;
}
.container {
  max-width: 600px; margin: 0 auto; background: var(--color-surface);
  border-radius: var(--radius-xl); box-shadow: var(--shadow-lg); padding: var(--space-24);
}
.header { text-align: center; margin-bottom: var(--space-24); }
.header h1 {
  font-size: var(--font-size-3xl); color: var(--christmas-red);
  margin-bottom: var(--space-8); display: flex; align-items: center; justify-content: center; gap: var(--space-8);
}
.stats {
  display: flex; justify-content: space-around; margin-bottom: var(--space-24);
  padding: var(--space-16); background: rgba(var(--color-teal-500-rgb), 0.1); border-radius: var(--radius-base);
}
.stat { text-align: center; }
.stat-value { font-size: var(--font-size-2xl); font-weight: 600; color: var(--color-primary); }
.stat-label { font-size: var(--font-size-sm); color: var(--color-text-secondary); margin-top: var(--space-4); }

/* Admin panel */
.admin-panel {
  background: rgba(var(--color-purple-500-rgb), 0.1); border: 2px solid var(--color-admin);
  border-radius: var(--radius-base); padding: var(--space-16); margin-bottom: var(--space-24);
}
.admin-title {
  font-size: var(--font-size-xl); font-weight: 600; color: var(--color-admin);
  margin-bottom: var(--space-16); text-align: center;
}
.admin-actions {
  display: flex; gap: var(--space-8); flex-wrap: wrap;
}
.btn-admin {
  background: var(--color-admin); color: var(--color-white);
  padding: var(--space-12); border: none; border-radius: var(--radius-base);
  font-weight: 600; cursor: pointer; flex: 1; min-width: 120px;
}
.btn-admin:hover { opacity: 0.9; }
.admin-info {
  background: rgba(var(--color-purple-500-rgb), 0.05); padding: var(--space-12);
  border-radius: var(--radius-base); margin-top: var(--space-12); font-size: var(--font-size-sm);
}

/* Timer sp√©cial */
.timer-display {
  text-align: center; margin-bottom: var(--space-16); padding: var(--space-16);
  background: rgba(var(--color-yellow-500-rgb), 0.2); border: 2px solid var(--color-warning);
  border-radius: var(--radius-base); font-size: var(--font-size-2xl); font-weight: 600;
  color: var(--color-warning);
}
.timer-display.expired { background: rgba(var(--color-red-500-rgb), 0.2); border-color: var(--color-error); color: var(--color-error); }

.players { display: flex; justify-content: space-around; margin-bottom: var(--space-24); gap: var(--space-8); }
.player { text-align: center; padding: var(--space-12); border-radius: var(--radius-base); background: var(--color-background); flex: 1; transition: all 0.3s ease; }
.player.active { background: rgba(var(--color-teal-500-rgb), 0.2); border: 2px solid var(--color-primary); }
.player.waiting { opacity: 0.6; }
.player.first { background: rgba(var(--color-yellow-500-rgb), 0.2); border: 2px solid var(--color-warning); }
.player-name { font-weight: 600; margin-bottom: var(--space-4); }
.player-status { font-size: var(--font-size-sm); color: var(--color-text-secondary); }
.player-status.selected { color: var(--color-success); font-weight: 600; }
.player-status.first { color: var(--color-warning); font-weight: 600; }

.grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: var(--space-12); margin-bottom: var(--space-24); }
@media (min-width: 480px) { .grid { grid-template-columns: repeat(5, 1fr); } }

.card {
  aspect-ratio: 1; border-radius: var(--radius-lg); cursor: pointer; position: relative; transition: all 0.3s ease;
  background: var(--color-background); border: 3px solid var(--color-border);
  overflow: hidden; -webkit-overflow-scrolling: touch; isolation: isolate;
}
.card:hover:not(.revealed):not(.my-selected):not(.disabled):not(.locked) { transform: scale(1.05); box-shadow: var(--shadow-md); }
.card.my-selected { border-color: var(--color-primary); box-shadow: 0 0 0 4px rgba(var(--color-teal-500-rgb), 0.3); transform: scale(1.05); }
.card.my-selected .card-inner { -webkit-transform: rotateY(180deg); transform: rotateY(180deg); transition: transform 0.6s; }
.card.revealed { border-color: var(--color-success); cursor: default; }
.card.revealed .card-inner { -webkit-transform: rotateY(180deg); transform: rotateY(180deg); }
.card.disabled { opacity: 0.5; cursor: not-allowed; }
.card.locked { opacity: 0.7; cursor: not-allowed; }

.card-inner {
  width: 100%; height: 100%; position: relative; -webkit-transform-style: preserve-3d; transform-style: preserve-3d;
  -webkit-transform: translateZ(0); transform: translateZ(0); transition: transform 0.6s;
}
.card-face {
  position: absolute; width: 100%; height: 100%; -webkit-backface-visibility: hidden; backface-visibility: hidden;
  border-radius: var(--radius-lg); display: flex; align-items: center; justify-content: center; overflow: hidden;
}
.card-back { background: linear-gradient(135deg, var(--christmas-red), var(--christmas-green)); color: var(--color-white); font-size: var(--font-size-3xl); }
.card-front { -webkit-transform: rotateY(180deg); transform: rotateY(180deg); background: var(--color-white); display: flex; align-items: center; justify-content: center; padding: 6px; }
.card-front img {
  display: block; width: auto; height: auto; max-width: 100%; max-height: 100%; object-fit: contain;
  -webkit-user-drag: none; user-select: none; border-radius: inherit; background: transparent;
}

.message { text-align: center; padding: var(--space-16); border-radius: var(--radius-base); margin-bottom: var(--space-16); font-weight: 500; }
.message.success { background: rgba(var(--color-green-500-rgb), 0.15); color: var(--color-success); border: 2px solid var(--color-success); }
.message.error { background: rgba(var(--color-red-500-rgb), 0.15); color: var(--color-error); border: 2px solid var(--color-error); }
.message.info { background: rgba(var(--color-teal-500-rgb), 0.15); color: var(--color-primary); border: 2px solid var(--color-primary); }
.message.warning { background: rgba(var(--color-yellow-500-rgb), 0.15); color: var(--color-warning); border: 2px solid var(--color-warning); }
.message.admin { background: rgba(var(--color-purple-500-rgb), 0.15); color: var(--color-admin); border: 2px solid var(--color-admin); }

.btn { width: 100%; padding: var(--space-16); border: none; border-radius: var(--radius-base); font-size: var(--font-size-lg); font-weight: 600; cursor: pointer; transition: all 0.3s ease; }
.btn-primary { background: var(--color-primary); color: var(--color-white); }
.btn-primary:hover { background: var(--color-primary-hover); transform: translateY(-2px); box-shadow: var(--shadow-md); }
.btn-primary:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }

.waiting-screen { text-align: center; padding: var(--space-32); }
.waiting-screen h2 { font-size: var(--font-size-2xl); margin-bottom: var(--space-24); color: var(--color-text); }
.player-list { margin: var(--space-24) 0; }
.player-item {
  display: flex; align-items: center; justify-content: center; gap: var(--space-8);
  padding: var(--space-12); margin: var(--space-8) 0; border-radius: var(--radius-base);
  background: var(--color-background); font-size: var(--font-size-lg);
}
.player-item.ready { background: rgba(var(--color-green-500-rgb), 0.15); }

.confetti { position: fixed; width: 10px; height: 10px; background: var(--christmas-gold); position: absolute; animation: confetti-fall 3s linear; }
@keyframes confetti-fall { to { transform: translateY(100vh) rotate(360deg); opacity: 0; } }

.victory-screen { text-align: center; padding: var(--space-32); }
.victory-screen h2 { font-size: var(--font-size-3xl); color: var(--christmas-red); margin-bottom: var(--space-24); }
.victory-time { font-size: var(--font-size-2xl); color: var(--color-primary); margin-bottom: var(--space-32); font-weight: 600; }

.hidden { display: none !important; }
  </style>
</head>
<body>
  <div class="container">
    <!-- Panneau Admin -->
    <div id="adminPanel" class="admin-panel hidden">
      <div class="admin-title">üîß Panneau Administrateur</div>
      <div class="admin-actions">
        <button class="btn-admin" id="resetGameBtn">üîÑ R√©initialiser la partie</button>
        <button class="btn-admin" id="resetPlayersBtn">üë• Reset joueurs</button>
        <button class="btn-admin" id="forceStartBtn">üöÄ Forcer le d√©marrage</button>
        <button class="btn-admin" id="debugInfoBtn">üêõ Infos debug</button>
      </div>
      <div class="admin-info">
        <strong>Mode Admin activ√©</strong> - Utilisez ces boutons pour d√©bloquer ou r√©initialiser la partie.
        <br>Pour revenir en mode joueur : <code>/?player=leon|capucine|firmin</code>
      </div>
    </div>

    <!-- √âcran d'attente -->
    <div id="waitingScreen" class="waiting-screen">
      <div class="header"><h1>üéÑ Memory de No√´l Collaboratif üéÅ</h1></div>
      <h2>Joueurs connect√©s</h2>
      <div class="player-list">
        <div class="player-item" id="playerLeon"><span>üë¶ L√©on</span><span id="statusLeon">‚è≥ En attente...</span></div>
        <div class="player-item" id="playerCapucine"><span>üëß Capucine</span><span id="statusCapucine">‚è≥ En attente...</span></div>
        <div class="player-item" id="playerFirmin"><span>üë¶ Firmin</span><span id="statusFirmin">‚è≥ En attente...</span></div>
      </div>
      <button class="btn btn-primary" id="readyBtn" disabled>Je suis pr√™t !</button>
      <p style="margin-top: var(--space-16); color: var(--color-text-secondary); font-size: var(--font-size-sm);">En attente des autres joueurs...</p>
    </div>

    <!-- √âcran de jeu -->
    <div id="gameScreen" class="hidden">
      <div class="header"><h1>üéÑ Memory de No√´l üéÅ</h1></div>
      
      <!-- Timer compte √† rebours -->
      <div id="timerDisplay" class="timer-display hidden">
        ‚è±Ô∏è Temps restant: <span id="timerSeconds">10</span>s
      </div>

      <div class="stats">
        <div class="stat"><div class="stat-value" id="foundCount">0/10</div><div class="stat-label">Trouv√©es</div></div>
        <div class="stat"><div class="stat-value" id="gameTimer">0:00</div><div class="stat-label">Temps total</div></div>
      </div>
      
      <div class="players">
        <div class="player" id="leonPlayer"><div class="player-name">üë¶ L√©on</div><div class="player-status" id="leonStatus">En attente...</div></div>
        <div class="player" id="capucinePlayer"><div class="player-name">üëß Capucine</div><div class="player-status" id="capucineStatus">En attente...</div></div>
        <div class="player" id="firminPlayer"><div class="player-name">üë¶ Firmin</div><div class="player-status" id="firminStatus">En attente...</div></div>
      </div>
      
      <div id="messageBox" class="message hidden"></div>
      <div class="grid" id="cardGrid"></div>
      <button class="btn btn-primary hidden" id="resetBtn">Rejouer üîÑ</button>
    </div>

    <!-- √âcran de victoire -->
    <div id="victoryScreen" class="hidden victory-screen">
      <h2>üéâ F√©licitations ! üéâ</h2>
      <p class="victory-time">Temps total : <span id="finalTime">0:00</span></p>
      <p style="font-size: var(--font-size-lg); margin-bottom: var(--space-32); color: var(--color-text);">Vous avez trouv√© toutes les images ensemble ! üéÑ‚ú®</p>
      <button class="btn btn-primary" id="playAgainBtn">Rejouer üîÑ</button>
    </div>
  </div>

  <script type="module">
    // Firebase config
    const firebaseConfig = {
      apiKey: "AIzaSyAfiNtWKwVGmKPs0tgicoXwj5nVkhZn9zc",
      authDomain: "noel2025-robert.firebaseapp.com",
      databaseURL: "https://noel2025-robert-default-rtdb.europe-west1.firebasedatabase.app",
      projectId: "noel2025-robert",
      storageBucket: "noel2025-robert.firebasestorage.app",
      messagingSenderId: "172876284151",
      appId: "1:172876284151:web:b46253f95386aa4a7ad3f2"
    };

    // Import Firebase
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
    import { getDatabase, ref, set, onValue, update, remove } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js';

    // Init Firebase
    let app, database;
    try {
      app = initializeApp(firebaseConfig);
      database = getDatabase(app);
    } catch (error) {
      console.error("Erreur Firebase:", error);
      alert("‚ö†Ô∏è Firebase non configur√©. Consultez le README pour les instructions.");
    }

    const hasDB = !!database;

    // URL params
    const urlParams = new URLSearchParams(window.location.search);
    const currentPlayer = urlParams.get('player') || 'leon';
    const isAdmin = urlParams.get('admin') === 'true';
    const validPlayers = ['leon', 'capucine', 'firmin'];
    
    if (!isAdmin && !validPlayers.includes(currentPlayer)) {
      alert('Joueur invalide ! Utilisez ?player=leon, ?player=capucine, ?player=firmin ou ?admin=true');
    }

    // Refs Firebase
    const gameRef         = hasDB ? ref(database, 'game_session') : null;
    const playersRef      = hasDB ? ref(database, 'game_session/players') : null;
    const gameStateRef    = hasDB ? ref(database, 'game_session/game_state') : null;
    const revealedRef     = hasDB ? ref(database, 'game_session/revealed_images') : null;

    // √âl√©ments DOM
    const adminPanel = document.getElementById('adminPanel');
    const waitingScreen = document.getElementById('waitingScreen');
    const gameScreen = document.getElementById('gameScreen');
    const victoryScreen = document.getElementById('victoryScreen');
    const readyBtn = document.getElementById('readyBtn');
    const resetBtn = document.getElementById('resetBtn');
    const playAgainBtn = document.getElementById('playAgainBtn');
    const cardGrid = document.getElementById('cardGrid');
    const messageBox = document.getElementById('messageBox');
    const timerDisplay = document.getElementById('timerDisplay');
    const timerSeconds = document.getElementById('timerSeconds');

    // Boutons admin
    const resetGameBtn = document.getElementById('resetGameBtn');
    const resetPlayersBtn = document.getElementById('resetPlayersBtn');
    const forceStartBtn = document.getElementById('forceStartBtn');
    const debugInfoBtn = document.getElementById('debugInfoBtn');

    // √âtat du jeu
    let myOrder = [];
    let gameStartTime = null;
    let gameTimerInterval = null;
    let countdownInterval = null;
    let myCurrentSelection = null;
    let hasSelectedInCurrentRound = false; // Nouveau : verrouiller apr√®s s√©lection

    // Mode Admin
    if (isAdmin) {
      adminPanel.classList.remove('hidden');
      waitingScreen.classList.add('hidden');
      
      // Actions admin
      resetGameBtn.addEventListener('click', async () => {
        if (confirm('‚ö†Ô∏è R√©initialiser compl√®tement la partie ?')) {
          try {
            if (hasDB) await remove(gameRef);
            showMessage('üîÑ Partie r√©initialis√©e !', 'admin');
            setTimeout(() => location.reload(), 1000);
          } catch (e) {
            showMessage('‚ùå Erreur lors de la r√©initialisation', 'error');
          }
        }
      });

      resetPlayersBtn.addEventListener('click', async () => {
        if (confirm('üë• R√©initialiser seulement les joueurs ?')) {
          try {
            if (hasDB) {
              await remove(playersRef);
              await set(gameStateRef, {
                phase: 'idle',
                firstPlayer: null,
                timerEnd: null,
                currentSelections: {}
              });
            }
            showMessage('üë• Joueurs r√©initialis√©s !', 'admin');
          } catch (e) {
            showMessage('‚ùå Erreur lors du reset joueurs', 'error');
          }
        }
      });

      forceStartBtn.addEventListener('click', async () => {
        if (confirm('üöÄ Forcer le d√©marrage du jeu ?')) {
          try {
            if (hasDB) {
              await set(playersRef, {
                leon: { order: generateRandomOrder(), ready: true },
                capucine: { order: generateRandomOrder(), ready: true },
                firmin: { order: generateRandomOrder(), ready: true }
              });
            }
            showMessage('üöÄ D√©marrage forc√© !', 'admin');
          } catch (e) {
            showMessage('‚ùå Erreur lors du d√©marrage forc√©', 'error');
          }
        }
      });

      debugInfoBtn.addEventListener('click', async () => {
        try {
          if (hasDB) {
            onValue(gameRef, (snapshot) => {
              const data = snapshot.val();
              console.log('üêõ √âtat Firebase:', data);
              const info = `
√âtat du jeu: ${data?.game_state?.phase || 'non d√©fini'}
Premier joueur: ${data?.game_state?.firstPlayer || 'aucun'}
Joueurs pr√™ts: ${Object.keys(data?.players || {}).filter(p => data.players[p]?.ready).length}/3
Images r√©v√©l√©es: ${(data?.revealed_images || []).length}/10
              `.trim();
              alert(`üêõ Debug Info:\n${info}`);
            }, { onlyOnce: true });
          }
        } catch (e) {
          showMessage('‚ùå Erreur debug', 'error');
        }
      });
    }

    // Helpers UI
    function showMessage(text, type = 'info') {
      messageBox.textContent = text;
      messageBox.className = `message ${type}`;
      messageBox.classList.remove('hidden');
      setTimeout(() => messageBox.classList.add('hidden'), 3000);
    }

    function showTimer(seconds) {
      timerSeconds.textContent = seconds;
      timerDisplay.classList.remove('hidden', 'expired');
    }

    function hideTimer() {
      timerDisplay.classList.add('hidden');
      if (countdownInterval) {
        clearInterval(countdownInterval);
        countdownInterval = null;
      }
    }

    function expireTimer() {
      timerDisplay.classList.add('expired');
      timerSeconds.textContent = '0';
    }

    // Ordre al√©atoire
    function generateRandomOrder() {
      const order = Array.from({ length: 10 }, (_, i) => `pic${i + 1}`);
      for (let i = order.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [order[i], order[j]] = [order[j], order[i]];
      }
      return order;
    }

    // Init joueur
    async function initPlayer() {
      if (isAdmin) return;
      
      try {
        if (!hasDB) throw new Error('Database non initialis√©e');
        myOrder = generateRandomOrder();
        
        let retries = 3;
        while (retries > 0) {
          try {
            await set(ref(database, `game_session/players/${currentPlayer}`), {
              order: myOrder,
              ready: false
            });
            break;
          } catch (writeError) {
            retries--;
            console.warn(`Tentative d'√©criture √©chou√©e, ${retries} essais restants:`, writeError);
            if (retries === 0) throw writeError;
            await new Promise(resolve => setTimeout(resolve, 1000));
          }
        }
        
      } catch (e) {
        console.error('initPlayer error:', e);
        showMessage('Connexion Firebase difficile. R√©essayez ou contactez l\'admin.', 'error');
      } finally {
        if (readyBtn) readyBtn.disabled = false;
      }
    }

    // Start game
    function startGame() {
      if (isAdmin) return;
      
      waitingScreen.classList.add('hidden');
      gameScreen.classList.remove('hidden');

      gameStartTime = Date.now();
      startGameTimer();
      createCards();

      if (hasDB) {
        set(gameStateRef, {
          phase: 'idle',
          firstPlayer: null,
          timerEnd: null,
          currentSelections: {}
        });
        set(revealedRef, []);
      }
    }

    // Timer du jeu total
    function startGameTimer() {
      gameTimerInterval = setInterval(() => {
        const elapsed = Math.floor((Date.now() - gameStartTime) / 1000);
        const minutes = Math.floor(elapsed / 60);
        const seconds = elapsed % 60;
        const gt = document.getElementById('gameTimer');
        if (gt) gt.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
      }, 1000);
    }

    // Cr√©er les cartes
    function createCards() {
      cardGrid.innerHTML = '';
      myOrder.forEach((imageId, index) => {
        const card = document.createElement('div');
        card.className = 'card';
        card.dataset.imageId = imageId;
        card.innerHTML = `
          <div class="card-inner">
            <div class="card-face card-back">üéÅ</div>
            <div class="card-face card-front">
              <img src="images/${imageId}.png" alt="Image ${index + 1}">
            </div>
          </div>
        `;
        card.addEventListener('click', () => selectCard(imageId, card));
        cardGrid.appendChild(card);
      });
    }

    // S√©lection d'une carte - AVEC VERROUILLAGE
    async function selectCard(imageId, cardElement) {
      if (isAdmin) return;
      
      try {
        if (!hasDB) throw new Error('Database non initialis√©e');

        // V√©rifier si d√©j√† r√©v√©l√©e
        const revealed = await new Promise(resolve => {
          onValue(revealedRef, (snapshot) => {
            resolve(snapshot.val() || []);
          }, { onlyOnce: true });
        });
        if (revealed.includes(imageId)) return;

        // NOUVEAU : V√©rifier si j'ai d√©j√† s√©lectionn√© dans ce tour
        if (hasSelectedInCurrentRound) {
          showMessage('Vous avez d√©j√† fait votre choix pour ce tour !', 'warning');
          return;
        }

        // V√©rifier l'√©tat du jeu
        const gameState = await new Promise(resolve => {
          onValue(gameStateRef, (snapshot) => {
            resolve(snapshot.val() || {});
          }, { onlyOnce: true });
        });

        // Logique selon la phase
        if (gameState.phase === 'idle') {
          await update(gameStateRef, {
            phase: 'waiting',
            firstPlayer: currentPlayer,
            timerEnd: Date.now() + 10000,
            currentSelections: { [currentPlayer]: imageId }
          });
          
          // NOUVEAU : Marquer que j'ai s√©lectionn√©
          hasSelectedInCurrentRound = true;
          
        } else if (gameState.phase === 'waiting') {
          if (gameState.firstPlayer === currentPlayer) {
            showMessage('Vous avez d√©j√† choisi ! Attendez les autres joueurs.', 'warning');
            return;
          }
          
          const newSelections = { ...gameState.currentSelections, [currentPlayer]: imageId };
          await update(ref(database, 'game_session/game_state/currentSelections'), newSelections);
          
          // NOUVEAU : Marquer que j'ai s√©lectionn√©
          hasSelectedInCurrentRound = true;
          
        } else if (gameState.phase === 'evaluating') {
          showMessage('√âvaluation en cours, patientez...', 'info');
          return;
        }

        updateMySelection(imageId);

      } catch (e) {
        console.error('selectCard error:', e);
        showMessage('S√©lection impossible.', 'error');
      }
    }

    // Mise √† jour de ma s√©lection locale
    function updateMySelection(imageId) {
      myCurrentSelection = imageId;
      document.querySelectorAll('.card').forEach(card => {
        card.classList.remove('my-selected');
        if (card.dataset.imageId === imageId && !card.classList.contains('revealed')) {
          card.classList.add('my-selected');
        }
      });
    }

    function clearMySelection() {
      myCurrentSelection = null;
      hasSelectedInCurrentRound = false; // NOUVEAU : Reset du verrouillage
      document.querySelectorAll('.card').forEach(card => {
        card.classList.remove('my-selected', 'locked');
      });
    }

    // Timer compte √† rebours - AVEC TIMEOUT AUTOMATIQUE
    function startCountdown(endTime) {
      if (countdownInterval) clearInterval(countdownInterval);
      
      countdownInterval = setInterval(async () => {
        const remaining = Math.max(0, Math.ceil((endTime - Date.now()) / 1000));
        
        if (remaining > 0) {
          showTimer(remaining);
        } else {
          clearInterval(countdownInterval);
          expireTimer();
          
          // NOUVEAU : Timeout automatique - pas d'attente
          try {
            await handleTimeout();
          } catch (e) {
            console.error('Erreur timeout automatique:', e);
          }
        }
      }, 100);
    }

    // NOUVEAU : Gestion du timeout automatique
    async function handleTimeout() {
      if (!hasDB) return;
      
      showMessage('‚è∞ Trop tard ! Nouveau tour.', 'error');
      
      // Reset imm√©diat sans attendre
      setTimeout(async () => {
        hideTimer();
        clearMySelection();
        await set(gameStateRef, {
          phase: 'idle',
          firstPlayer: null,
          timerEnd: null,
          currentSelections: {}
        });
      }, 1500);
    }

    // √âvaluer les s√©lections
    async function evaluateSelections(gameState) {
      try {
        if (!hasDB) return;

        await update(gameStateRef, { phase: 'evaluating' });

        const selections = gameState.currentSelections || {};
        const selectionValues = Object.values(selections);
        const allPlayersSelected = Object.keys(selections).length === 3;

        if (allPlayersSelected && selectionValues[0] === selectionValues[1] && selectionValues[1] === selectionValues[2]) {
          const imageId = selectionValues[0];

          const revealed = await new Promise(resolve => {
            onValue(revealedRef, (snapshot) => {
              resolve(snapshot.val() || []);
            }, { onlyOnce: true });
          });

          if (!revealed.includes(imageId)) {
            revealed.push(imageId);
            await set(revealedRef, revealed);
          }

          showMessage('üéâ Parfait ! Image trouv√©e ! +1 point', 'success');
          createConfetti();

          if (revealed.length === 10) {
            setTimeout(() => showVictory(), 1000);
            return;
          }

        } else {
          showMessage('‚ùå Images diff√©rentes ! Essayez encore cette carte.', 'error');
        }

        setTimeout(async () => {
          hideTimer();
          clearMySelection();
          await set(gameStateRef, {
            phase: 'idle',
            firstPlayer: null,
            timerEnd: null,
            currentSelections: {}
          });
        }, 2000);

      } catch (e) {
        console.error('evaluateSelections error:', e);
      }
    }

    // Listeners Firebase (seulement si pas admin)
    if (hasDB && !isAdmin) {
      // √âcoute joueurs (pr√™ts)
      onValue(playersRef, (snapshot) => {
        const players = snapshot.val() || {};
        ['leon', 'capucine', 'firmin'].forEach(player => {
          const statusEl = document.getElementById(`status${player.charAt(0).toUpperCase() + player.slice(1)}`);
          const playerEl = document.getElementById(`player${player.charAt(0).toUpperCase() + player.slice(1)}`);
          if (!statusEl || !playerEl) return;
          
          if (players[player]?.ready) {
            statusEl.textContent = '‚úÖ Pr√™t !';
            statusEl.style.color = 'var(--color-success)';
            playerEl.classList.add('ready');
          } else if (players[player]) {
            statusEl.textContent = '‚è≥ En attente...';
            statusEl.style.color = '';
            playerEl.classList.remove('ready');
          }
        });

        const allReady = ['leon', 'capucine', 'firmin'].every(p => players[p]?.ready);
        if (allReady && !gameStartTime) {
          setTimeout(startGame, 1000);
        }
      });

      // √âcoute √©tat du jeu
      onValue(gameStateRef, (snapshot) => {
        const gameState = snapshot.val() || {};

        if (gameState.phase === 'waiting') {
          if (gameState.timerEnd) {
            startCountdown(gameState.timerEnd);
          }

          ['leon', 'capucine', 'firmin'].forEach(player => {
            const statusEl = document.getElementById(`${player}Status`);
            const playerEl = document.getElementById(`${player}Player`);
            if (!statusEl || !playerEl) return;

            playerEl.classList.remove('first', 'active', 'waiting');
            statusEl.classList.remove('first', 'selected');

            if (gameState.firstPlayer === player) {
              statusEl.textContent = 'üéØ A choisi en premier';
              statusEl.classList.add('first');
              playerEl.classList.add('first');
            } else if (gameState.currentSelections?.[player]) {
              statusEl.textContent = '‚úÖ A choisi';
              statusEl.classList.add('selected');
              playerEl.classList.add('active');
            } else {
              statusEl.textContent = '‚è≥ Choisit...';
              playerEl.classList.add('waiting');
            }
          });

          const selections = gameState.currentSelections || {};
          const allSelected = Object.keys(selections).length === 3;

          // NOUVEAU : Pas de v√©rification du timer expir√© ici (g√©r√© par startCountdown)
          if (allSelected) {
            evaluateSelections(gameState);
          }

          // NOUVEAU : Verrouiller les cartes apr√®s s√©lection
          document.querySelectorAll('.card').forEach(card => {
            if (!card.classList.contains('revealed')) {
              if (gameState.firstPlayer === currentPlayer || hasSelectedInCurrentRound) {
                card.classList.add('locked');
              } else {
                card.classList.remove('locked');
              }
            }
          });

        } else if (gameState.phase === 'idle') {
          hideTimer();
          clearMySelection();
          
          ['leon', 'capucine', 'firmin'].forEach(player => {
            const statusEl = document.getElementById(`${player}Status`);
            const playerEl = document.getElementById(`${player}Player`);
            if (!statusEl || !playerEl) return;

            statusEl.textContent = 'Choisissez une carte';
            statusEl.classList.remove('first', 'selected');
            playerEl.classList.remove('first', 'active', 'waiting');
          });

          document.querySelectorAll('.card').forEach(card => {
            if (!card.classList.contains('revealed')) {
              card.classList.remove('disabled', 'locked');
            }
          });
        }
      });

      // √âcoute images r√©v√©l√©es
      onValue(revealedRef, (snapshot) => {
        const revealed = snapshot.val() || [];
        const fc = document.getElementById('foundCount');
        if (fc) fc.textContent = `${revealed.length}/10`;
        
        revealed.forEach(imageId => {
          document.querySelectorAll(`.card[data-image-id="${imageId}"]`).forEach(card => {
            card.classList.add('revealed');
            card.classList.remove('my-selected', 'disabled', 'locked');
          });
        });
      });
    } else if (!hasDB) {
      if (readyBtn) readyBtn.disabled = false;
      showMessage('Firebase indisponible.', 'error');
    }

    // Click "Je suis pr√™t"
    if (readyBtn) {
      readyBtn.addEventListener('click', async () => {
        if (isAdmin) return;
        
        readyBtn.disabled = true;
        try {
          if (!hasDB) throw new Error('Database non initialis√©e');
          
          const timeout = new Promise((_, reject) => 
            setTimeout(() => reject(new Error('Timeout')), 5000)
          );
          
          await Promise.race([
            update(ref(database, `game_session/players/${currentPlayer}`), { ready: true }),
            timeout
          ]);
          
        } catch (e) {
          console.error('ready click error:', e);
          showMessage('Impossible de signaler "Pr√™t". Utilisez le mode admin pour d√©bloquer.', 'error');
          readyBtn.disabled = false;
        }
      });
    }

    // Confettis
    function createConfetti() {
      for (let i = 0; i < 30; i++) {
        setTimeout(() => {
          const confetti = document.createElement('div');
          confetti.className = 'confetti';
          confetti.style.left = Math.random() * 100 + '%';
          confetti.style.background = ['#ffd700', '#ff6b6b', '#4ecdc4'][Math.floor(Math.random() * 3)];
          document.body.appendChild(confetti);
          setTimeout(() => confetti.remove(), 3000);
        }, i * 30);
      }
    }

    // Victoire
    function showVictory() {
      clearInterval(gameTimerInterval);
      hideTimer();
      gameScreen.classList.add('hidden');
      victoryScreen.classList.remove('hidden');

      const elapsed = Math.floor((Date.now() - gameStartTime) / 1000);
      const minutes = Math.floor(elapsed / 60);
      const seconds = elapsed % 60;
      const ft = document.getElementById('finalTime');
      if (ft) ft.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;

      for (let i = 0; i < 100; i++) {
        setTimeout(() => createConfetti(), i * 50);
      }
    }

    // Reset / Rejouer
    if (playAgainBtn) {
      playAgainBtn.addEventListener('click', async () => {
        try {
          if (hasDB) await remove(gameRef);
        } finally {
          location.reload();
        }
      });
    }

    if (resetBtn) {
      resetBtn.addEventListener('click', async () => {
        try {
          if (hasDB) await remove(gameRef);
        } finally {
          location.reload();
        }
      });
    }

    // Lancement
    if (!isAdmin) {
      initPlayer();
    }
  </script>
</body>
</html>
